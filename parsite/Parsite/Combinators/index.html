<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Combinators (parsite.Parsite.Combinators)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">parsite</a> &#x00BB; <a href="../index.html">Parsite</a> &#x00BB; Combinators</nav><header class="odoc-preamble"><h1>Module <code><span>Parsite.Combinators</span></code></h1><p>Parsite functions, courtesy of faber-1</p></header><div class="odoc-content"><p>NOTE ON FUNCTIONS THAT TAKE PARSERS AS INPUT: Lose messages are propagated from input parsers unless stated otherwise.</p><div class="odoc-spec"><div class="spec exception anchored" id="exception-EmptyList"><a href="#exception-EmptyList" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">EmptyList</span> <span class="keyword">of</span> string</span></code></div><div class="spec-doc"><p>Thrown whenever functions that take parser lists take empty inputs</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(/&gt;)"><a href="#val-(/&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (/&gt;) : 
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'c</span>)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span> * <span class="type-var">'c</span>)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span></span></code></div><div class="spec-doc"><p>Infix concat operator. Concatenates two parsers and creates a new parser that contains the two parser requirements in a tuple. I'd recommend performing extra operations on a tuple-returning parser.</p><p>Example of Win:</p><pre class="language-ocaml"><code>let p1 = p_string &quot;hi&quot; in
let p2 = p_string &quot;hello&quot; in 

let pfin = p1 /&gt; p2 in 

pfin &quot;hihello&quot; = Win ((&quot;hi&quot;, &quot;hello&quot;), &quot;&quot;)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(&gt;/)"><a href="#val-(&gt;/)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;/) : 
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span></span></code></div><div class="spec-doc"><p>Infix or operator. Creates a parser that accepts either the input from the first or second parser passed in.</p><p>Example of Win:</p><pre class="language-ocaml"><code>let p1 = p_char 'a' in 
let p2 = p_char 'b' in 

let pfin = p1 &gt;/ p2 in 

(pfin &quot;ae&quot; = Win ('a', &quot;e&quot;)) &amp;&amp; (pfin &quot;be&quot; = Win ('b', &quot;e&quot;))</code></pre><p>Example of Lose:</p><pre class="language-ocaml"><code>let p1 = p_char 'a' in 
let p2 = p_char 'b' in 

let pfin = p1 &gt;/ p2 in 

(pfin &quot;wa&quot; = Lose &quot;Or Problem: Failed with following errors: (Expected char 'a', got char 'w') and (Expected char 'b', got char 'w')&quot; )</code></pre><p>Lose message spits out Lose messages of both inputs</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(/&gt;/)"><a href="#val-(/&gt;/)" class="anchor"></a><code><span><span class="keyword">val</span> (/&gt;/) : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'c</span>)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span></span></code></div><div class="spec-doc"><p>Infix map operator. Takes a parser and a function and applies it to the parser's output. It returns a parser with a function applied to the original requirement match</p><p>Example:</p><pre class="language-ocaml"><code>let p = p_string &quot;hi&quot; in 
let f = fun x -&gt; &quot;H&quot; ^ x in 

let pfin = p /&gt;/ f in 

pfin &quot;hi aa&quot; = Win (&quot;Hhi&quot;, &quot; aa&quot;)</code></pre><p>NOTE: The function is applied to the parser's *output*. The function is not applying anything to the input of the parser.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(@&gt;)"><a href="#val-(@&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (@&gt;) : 
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span></span></code></div><div class="spec-doc"><p>Infix ignore left operator. Takes two parsers and runs them both, but only keeps the result of the right side parser and discards the left.</p><p>Example:</p><pre class="language-ocaml"><code>let p1 = p_string &quot;ignore&quot; in
let p2 = p_string &quot;keep&quot; in

let pfin = p1 @&gt; p2 in 

pfin &quot;ignorekeeprest&quot; = Win (&quot;keep&quot;, &quot;rest&quot;)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(&gt;@)"><a href="#val-(&gt;@)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;@) : 
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span></span></code></div><div class="spec-doc"><p>Infix ignore right operator. Takes two parsers, runs them, and keeps the result of the left side parser and discards the right.</p><p>Example:</p><pre class="language-ocaml"><code>let p1 = p_string &quot;keep&quot; in
let p2 = p_string &quot;ignore&quot; in

let pfin = p1 &gt;@ p2 in 

pfin &quot;keepignorerest&quot; = Win (&quot;keep&quot;, &quot;rest&quot;)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-p_middle"><a href="#val-p_middle" class="anchor"></a><code><span><span class="keyword">val</span> p_middle : 
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span></span></code></div><div class="spec-doc"><p>Takes 3 parsers, runs them all, but only keeps the middle parser's result.</p><p>Example:</p><pre class="language-ocaml"><code>let p1 = p_string &quot;i1&quot; in
let p2 = p_string &quot;keep&quot; in
let p3 = p_string &quot;i2&quot; in 

let pfin = p_middle p1 p2 p3 in 

pfin &quot;i1keepi2rest&quot; = Win (&quot;keep&quot;, &quot;rest&quot;)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-p_char"><a href="#val-p_char" class="anchor"></a><code><span><span class="keyword">val</span> p_char : <span>char <span class="arrow">&#45;&gt;</span></span> <span><span>(string, char)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span></span></code></div><div class="spec-doc"><p>Parses a single charcter.</p><p>Lose messages are either of form <code>&quot;Empty String&quot;</code> or <code>&quot;Expected char '%c', got char '%c'&quot;</code>.</p><p>Example:</p><pre class="language-ocaml"><code>let pa = p_char 'a' in 

pa &quot;abc&quot; = Win ('a', &quot;bc&quot;)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-p_list"><a href="#val-p_list" class="anchor"></a><code><span><span class="keyword">val</span> p_list : <span><span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span><span class="type-var">'b</span> list</span>)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span></span></code></div><div class="spec-doc"><p>Takes a list of parsers, and creates a parser that parses into a 'b list type of the output of the original parser list. Essentially takes the parsers and creates one parser that concats them all.</p><p>Example:</p><pre class="language-ocaml"><code>let ps = ['a'; 'b'; 'c'] |&gt; List.map p_char in 

let pfin = p_list ps in 

pfin &quot;abcde&quot; = Win (['a'; 'b'; 'c'], &quot;de&quot;)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-p_either"><a href="#val-p_either" class="anchor"></a><code><span><span class="keyword">val</span> p_either : <span><span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span></span></code></div><div class="spec-doc"><p>Takes a list of parsers, and accepts inputs for matches for any parser in the list.</p><p>Example:</p><pre class="language-ocaml"><code>let pfin = ['1'; '2'; '3'] |&gt; List.map p_char |&gt; p_either in 

(pfin &quot;1rest&quot; = Win ('1', &quot;rest&quot;)) &amp;&amp;
(pfin &quot;2rest&quot; = Win ('2', &quot;rest&quot;)) &amp;&amp; 
(pfin &quot;3rest&quot; = Win ('3', &quot;rest&quot;))</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-p_string"><a href="#val-p_string" class="anchor"></a><code><span><span class="keyword">val</span> p_string : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(string, string)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span></span></code></div><div class="spec-doc"><p>Creates parser for a specific string.</p><p>Lose message is of form <code>&quot;Expected string '%s', got '%s'&quot;</code></p><p>Example:</p><pre class="language-ocaml"><code>let p1 = p_string &quot;hey&quot; in 

p1 &quot;heyhi&quot; = Win (&quot;hey&quot;, &quot;hi&quot;)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-p_concat_str"><a href="#val-p_concat_str" class="anchor"></a><code><span><span class="keyword">val</span> p_concat_str : 
  <span><span><span>(string, string)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(string, string)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(string, string)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span></span></code></div><div class="spec-doc"><p>Concats two string parsers together.</p><p>Example:</p><pre class="language-ocaml"><code>let p1 = p_string &quot;time&quot; in
let p2 = p_string &quot;zone&quot; in 

let p_fin = p_concat_str p1 p2 in 

p_fin &quot;timezone difference&quot; = Win(&quot;timezone&quot;, &quot; difference&quot;) </code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-p_concat_strs"><a href="#val-p_concat_strs" class="anchor"></a><code><span><span class="keyword">val</span> p_concat_strs : 
  <span><span><span><span>(string, string)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(string, string)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span></span></code></div><div class="spec-doc"><p>Concats multiple string parsers together.</p><p>Example:</p><pre class="language-ocaml"><code>let pfin = [&quot;he&quot;; &quot;ha&quot;; &quot;ts&quot;] |&gt; List.map p_string |&gt; p_concat_strs in 

pfin &quot;hehatsthehat&quot; = Win (&quot;hehats&quot;, &quot;thehat&quot;)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-p_char_as_str"><a href="#val-p_char_as_str" class="anchor"></a><code><span><span class="keyword">val</span> p_char_as_str : <span>char <span class="arrow">&#45;&gt;</span></span> <span><span>(string, string)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span></span></code></div><div class="spec-doc"><p>Parses single character as a string</p><p>Example:</p><pre class="language-ocaml"><code>let pa = p_char_as_str 'a' in 

pa &quot;abc&quot; = Win (&quot;a&quot;, &quot;bc&quot;)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-p_many"><a href="#val-p_many" class="anchor"></a><code><span><span class="keyword">val</span> p_many : <span><span><span>(string, string)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(string, string)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span></span></code></div><div class="spec-doc"><p>Takes string parser, matches it 0 or more times. Like * in regex.</p><p>Example:</p><pre class="language-ocaml"><code>let p = p_string &quot;he&quot; in 

let pfin = p_many p in 

(pfin &quot;..&quot; = Win (&quot;&quot;, &quot;..&quot;)) &amp;&amp;
(pfin &quot;he..&quot; = Win (&quot;he&quot;, &quot;..&quot;)) &amp;&amp; 
(pfin &quot;hehehehehehehehehehehe&quot; = Win (&quot;hehehehehehehehehehehe&quot;, &quot;&quot;))</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-p_many1"><a href="#val-p_many1" class="anchor"></a><code><span><span class="keyword">val</span> p_many1 : <span><span><span>(string, string)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(string, string)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span></span></code></div><div class="spec-doc"><p>Takes string parser, matches it 1 or more times. Like + in regex.</p><p>Example:</p><pre class="language-ocaml"><code>let p = p_string &quot;he&quot; in 

let pfin = p_many1 p in 

(pfin &quot;..&quot; = Lose &quot;Expected string 'he', got '..'&quot;) &amp;&amp;
(pfin &quot;he&quot; = Win (&quot;he&quot;, &quot;&quot;)) &amp;&amp; 
(pfin &quot;hehehehehehehehehehehe&quot; = Win (&quot;hehehehehehehehehehehe&quot;, &quot;&quot;))</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-p_lister"><a href="#val-p_lister" class="anchor"></a><code><span><span class="keyword">val</span> p_lister : 
  <span><span><span><span>(string, string)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(string, string)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(string, string)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span></span></code></div><div class="spec-doc"><p>Takes a list of parsers and a delimiter, and creates a parser with the delimiter between each string in the list.</p><p>Example:</p><pre class="language-ocaml"><code>let ps = [&quot;one&quot;; &quot;two&quot;; &quot;three&quot;] |&gt; List.map p_string in 
let p = [&quot;single&quot;] |&gt; List.map p_string in
let delim = p_string &quot;,&quot; in 

let ps' = p_lister ps delim in 
let p' = p_lister p delim in 

(ps' &quot;one,two,threerest&quot; = Win (&quot;one,two,three&quot;, &quot;rest&quot;)) &amp;&amp; 
(p' &quot;singlerest&quot; = Win (&quot;single&quot;, &quot;rest&quot;))</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-p_lower"><a href="#val-p_lower" class="anchor"></a><code><span><span class="keyword">val</span> p_lower : <span><span>(string, string)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span></span></code></div><div class="spec-doc"><p>Matches lowercase letters</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-p_upper"><a href="#val-p_upper" class="anchor"></a><code><span><span class="keyword">val</span> p_upper : <span><span>(string, string)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span></span></code></div><div class="spec-doc"><p>Matches uppercase letters</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-p_digits"><a href="#val-p_digits" class="anchor"></a><code><span><span class="keyword">val</span> p_digits : <span><span>(string, string)</span> <a href="../Types/index.html#type-p_func">Types.p_func</a></span></span></code></div><div class="spec-doc"><p>Matches digits</p></div></div></div></body></html>
